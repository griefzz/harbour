{"config":{"lang":["en"],"separator":"[\\s\\-\\.]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Web Server Framework for Modern C++","text":""},{"location":"features/cookies/","title":"Cookies","text":"<p>Harbour comes with its own cookie storage API to fasciliate a seamless way to create and manage user sessions.</p> <p>A full Cookies example can be found here.</p>"},{"location":"features/cookies/#setting-cookies","title":"Setting Cookies","text":"<p>If you want to set the cookies for a client, you need to create a Cookies object and then add it to a Response.</p> <p>Example</p> <p>This is an example that creates an empty cookies object and inserts some data into it.</p> <p>Then creates a response that you can send to the client setting their cookies</p> <pre><code>    // Create an empty Cookies object\n    auto cookies = Cookies::create();\n\n    // The Cookies object acts as a map&lt;string, string&gt;\n    cookies[\"id\"]   = \"123\";\n    cookies[\"name\"] = \"bob\";\n\n    // Create a Response with cookies\n    auto response = Response().with_cookies(cookies);\n</code></pre> <p>Note</p> <p>While Harbour by default will construct a Response with a http::Status::OK.  The Set-Cookie header will only be valid if Response has http::Status::OK.</p>"},{"location":"features/cookies/#getting-cookies","title":"Getting Cookies","text":"<p>In order to parse the cookies from the client we need to create a Cookies object from a Request</p> <p>Example</p> <p>This example will parse the Cookies from a Request. Check if id and name exist in the Cookies object. Then log the information if it exists.</p> <pre><code>auto GetCookies(const Request &amp;req) {\n    // When creating a Cookies object from another source\n    // we need to handle the possibility of a parsing error\n    if (auto cookies = Cookies::create(req)) {\n        // The cookies object was parsed successfully\n        // Cookies acts as a map&lt;string, string&gt; so grabbing\n        // data from the [] operator will automatically insert\n        // an entry into the map. If you want to know if a cookie\n        // exists in the map use the get method which returns a std::optional\n        auto id = cookies.get(\"id\");\n        auto name = cookies.get(\"name\");\n        if (id &amp;&amp; name) // check if the std::optional holds a value\n            log::info(\"id: {}, name: {}\", *id, *name);\n    }\n}\n</code></pre>"},{"location":"features/cookies/#parameters","title":"Parameters","text":"<p>While the Cookies object is a simple map, theres quite a bit of metadata associated with cookies that the browser can accept. Harbour makes this as easy as possible using the Cookies <code>with_*</code> methods.</p> <p>Example</p> <p>This example will construct a cookie with several parameters.</p> <pre><code>    // Create an expires for ten days from now\n    auto now               = std::chrono::system_clock::now();\n    auto ten_days          = std::chrono::hours(24 * 10);\n    auto ten_days_from_now = std::chrono::system_clock::to_time_t(now + ten_days);\n\n    // Create a Cookies object with some parameters\n    auto cookies = Cookies::create()\n                   .with_expires(ten_days_from_now) // Cookie expires 10 days from now\n                   .with_http_only()                // Only allow HTTP Responses to set cookies\n                   .with_secure();                  // Only allow this cookie on SSL connections\n</code></pre> <p>Note</p> <p>Heres the full list of a Cookies <code>with_*</code> parameters</p> <pre><code>    // Set the Expires attribute of the cookie to a certain date\n    auto with_expires(const std::chrono::system_clock::time_point &amp;date) -&gt; Cookies &amp;;\n\n    // Set the Max-Age attribute of a cookie\n    auto with_age(const std::chrono::seconds &amp;age) -&gt; Cookies &amp;;\n\n    // Set the Max-Age attribute of a cookie\n    auto with_age(std::size_t age) -&gt; Cookies &amp;;\n\n    // Set the Domain attribute of a cookie\n    auto with_domain(auto &amp;&amp;domain) -&gt; Cookies &amp;;\n\n    // Set the Path attribute of a cookie\n    auto with_path(auto &amp;&amp;path) -&gt; Cookies &amp;;\n\n    // Set the SameSite attribute of a cookie\n    auto with_same_site_policy(cookies::SameSitePolicy policy) -&gt; Cookies &amp;;\n\n    // Enable the Secure flag for a cookie\n    auto with_secure() -&gt; Cookies &amp;;\n\n    // Enable the HttpOnly flag for a cookie\n    auto with_http_only() -&gt; Cookies &amp;;\n</code></pre>"},{"location":"features/cookies/#converting-cookies","title":"Converting Cookies","text":"<p>The Cookies object implements a fmt::formatter. and the internal Cookies::Map implements the JSON adl_serializer.</p> <p>You can convert a Cookie::Map to and from json as well as printing out like so</p> <p>Example</p> <pre><code>auto cookies = Cookies::create();\ncookies[\"id\"] = \"123\";\ncookies[\"name\"] = \"bob\";\n\n// Convert the map to json\nauto j = json::serialize(cookies.data);\n\n// Convert the Cookies object to a string\nauto str = tmpl::render(\"{}\", cookies); // id=123; name=bob\n</code></pre>"},{"location":"features/dock/","title":"Dock","text":"<p>When you want your Ship to be executed for a client you need to Dock your Ship. Dock is Harbour's take on handler routing.</p> <p>A full dock example can be found here.</p>"},{"location":"features/dock/#introduction","title":"Introduction","text":"<p>Dock comes in 2 different flavours, <code>routed</code> and <code>global</code>.</p> <p>A <code>global</code> dock will execute Ships on any path in the server.</p> <p>A <code>routed</code> dock will execute Ships only on the specified route.</p> <p>Example</p> <p>This is an example of global Ship. Global Ships are executed on every connection after your routed Ships have finished.</p> <pre><code>harbour.dock(Log);\n</code></pre> <p>This is an example of a routed Ship. The routed Ship Counter will only be executed on the path /counter</p> <pre><code>harbour.dock(\"/counter\", Counter); // dock the ship to \"/counter\"\n</code></pre> <p>Note</p> <p>Remember that global Ships will only be executed after your routed Ships. If you need a specific Ship to act before another consider using Middleware.</p>"},{"location":"features/dock/#named-routes","title":"Named Routes","text":"<p>Harbour makes it easy to caputre a specific variable in a request path. Instead of manually parsing the Request::path from within a Ship, you can use the Named Routing construct.</p> <p>Named Routes are variables inside the path to your dock call specified with the ':' character.  if you specify a named route <code>/some/path/:var</code>, once a user requests <code>/some/path/foo</code>. The string <code>foo</code> and <code>var</code> will  be stored inside Request::route as an optional key/value pair.</p> <p>A Ship held on a specified route can process this like below.</p> <p>Example</p> <pre><code>// This Ship will print the route for a path if it exists.\n// Otherwise it will print the Request path.\nauto Routed(const Request &amp;req) -&gt; Response {\n    // Render a named route if it exists\n    if (auto route = req.route) {\n        // Routes contain a key value pair describing the route\n        // Key is the variable name stored on the Trie\n        // Value is the parsed Request path that matches Key\n        const auto &amp;[key, value] = *route;\n        return tmpl::render(\"{}: {}\", key, value);\n    }\n\n    // Render a normal route\n    return req.path;\n}\n\n...\n    // Named route using :name as the variable. Will accept any Method.\n    hb.dock(\"/hello/:name\", Routed);\n...\n</code></pre> <p>Note</p> <p>You can only specify one named route per path. And named routes must end will their name.</p> <ul> <li> <code>/api/v1/:foo</code></li> <li> <code>/api/v1/:foo/</code></li> <li> <code>/api/v1/:foo/:bar</code></li> <li> <code>/api/v1/:foo/bar</code></li> </ul> <p>Warning</p> <p>Named routes will consume all child routes of its path. For instance</p> <pre><code>// The named route will execute for all paths inside /api/v1/\nhb.dock(\"/api/v1/:foo\", Foo);\n\n// Bar will never be executed since everything above \n// /api/v1/ is consumed by the named route\nhb.dock(\"/api/v1/bar\", Bar);\n</code></pre>"},{"location":"features/dock/#constraints","title":"Constraints","text":"<p>By default Ships will execute on any HTTP request method. In order to reduce the boilerplate of defining specific allowed methods within a Ship, Harbour introduces the concept of Method Constraints</p> <p>Method Contraints are used as a chainable prefix to your dock command as described below.</p> <p>Example</p> <p>Only execute these Ships on a POST request.</p> <pre><code>hb.dock(http::Method::POST, \"/foo\", Foo);\nhb.dock(http::Method::POST, \"/bar\", Bar);\n</code></pre> <p>Chain together multiple Methods using the | operator.</p> <pre><code>hb.dock(http::Method::GET | http::Method::POST, \"/baz\", Baz)\n</code></pre> <p>Note</p> <p>At the moment only routed Ships are allowed Method Constraints. This will change in the near future to support all dock methods. If you need a global ship to only execute on a specific method. Consider this boilerplate</p> <pre><code>if (req.method == http::Method::POST) { ... }\n</code></pre>"},{"location":"features/json/","title":"JSON","text":"<p>Harbour loves JSON and tries to make it as easy as possible to work with.</p> <p>The included and fantastic nlohmann::json library provides everything you could want!</p> <p>Harbour provides a wrapper around the nlohmann::json type under json::json_t</p>"},{"location":"features/json/#serialization","title":"Serialization","text":"<p>Any type that fulfils the nlohman::json type can be used with Harbour's json::serialize</p> <p>Harbour provides a convenient method for serialization, but ultimately you're free to use the full power of nlohmann::json knowing harbour supports and encourages it!</p> <p>Example</p> <pre><code>// Converting raw JSON literal into a json object\nauto pirate = json::serialize(R\"({ \"ship\": \"Ol Skippy\", \"captain\": \"Pegleg Billy\" })\");\n\n// Converting a Cookie::Map into JSON\nauto cookies = json::serialize(cookies.data);\n\n// Converting a Request body into JSON and echo it back as JSON\nauto ToFromJson(const Request &amp;req) -&gt; json::json_t {\n    return json::serialize(req.body);\n}\n</code></pre>"},{"location":"features/json/#deserialization","title":"Deserialization","text":"<p>Any type that fulfils the requirements of the nlohman::json type can be used with Harbour's json::deserialize library can be deserialized!</p> <p>Example</p> <p>This example deserializes a pirate json object into a Boat struct </p> <pre><code>struct Boat {\n    std::string ship;\n    std::vector&lt;std::string&gt; crew;\n    std::string captain;\n\n    // HARBOUR_JSONABLE is a wrapper for NLOHMANN_DEFINE_TYPE_INTRUSIVE\n    HARBOUR_JSONABLE(Boat, ship, crew, captain);\n};\n\n// Create a json object\nauto pirate    = json::serialize(R\"({ \"ship\": \"Ol Skippy\", \"captain\": \"Pegleg Billy\" })\"); \npirate[\"crew\"] = {\"Bobby\", \"Johhny\", \"Tommy\"}; // Add some pirates\n\nBoat boat; // Initialize the boat for deserialization\njson::deserialize(pirates, boat); // deserialize pirates into the boat\n</code></pre>"},{"location":"features/logging/","title":"Logging","text":"<p>Harbour's logging isn't extensive, but its API is still useful. Since logging itself can bring in a myriad of design considerations and requirements per project, Harbour instead opts to simply provide a set of pretty-printed log functions wrapping fmtlib and callbacks to customize for your needs.</p> <p>Harbour always aims to provide you with as much flexibility as possible without making things complicated and logging is no different.</p> <p>A full logging API example can be found here.</p>"},{"location":"features/logging/#functions","title":"Functions","text":"<p>Harbour provides 3 different log functions.</p> <ul> <li>log::info - This function is for normal information.</li> <li>log::warn - This function is for unexpected but recoverable issues.</li> <li>log::critical - This function is for catastrohpic issues that may or may not be recoverable.</li> </ul> <p>Example</p> <p>The log functions are wrappers using fmtlib so any type that is implemented by a fmt::formatter works here.</p> <p>Some examples of possible usage.</p> <pre><code>log::info(\"Connection: {}:{}\", ip, port);\nlog::warn(\"Something unexpected happened: {}\", e.what());\nlog::critical(\"Everything is on fire! Send help!\");\n</code></pre>"},{"location":"features/logging/#callbacks","title":"Callbacks","text":"<p>To enable your own logging solutions harbour provides 3 callback coroutines for important server events.</p> <ul> <li>Connection - Callback for when a new connection happens.</li> <li>Warning - Callback for when a server warning event happens.</li> <li>Critical - Callback for when a server critical event happens.</li> </ul> <p>Example</p> <p>This example sets callbacks in a server::Settings object then passes them into a Harbour instance.</p> <pre><code>// For convenience\nusing harbour::server::SharedSocket;\n\n// Callback for when a server warning event happens\nauto OnConnection(SharedSocket socket, const std::string_view message) -&gt; awaitable&lt;void&gt; {\n    log::info(\"{}:{} \u2192 {}\", socket-&gt;address(), socket-&gt;port(), message);\n    co_return;\n}\n\n// Callback for when a server warning event happens\nauto OnWarning(SharedSocket socket, const std::string_view message) -&gt; awaitable&lt;void&gt; {\n    log::warn(\"{}:{} \u2192 {}\", socket-&gt;address(), socket-&gt;port(), message);\n    co_return;\n}\n\n// Callback for when a server critical event happens\nauto OnCritical(SharedSocket socket, const std::string_view message) -&gt; awaitable&lt;void&gt; {\n    log::critical(\"{}:{} \u2192 {}\", socket-&gt;address(), socket-&gt;port(), message);\n    co_return;\n}\n\nauto main() -&gt; int {\n    // Assign callbacks to the server settings using the with_* methods\n    auto settings = server::Settings()\n                            .with_on_connection(OnConnection)\n                            .with_on_warning(OnWarning)\n                            .with_on_critical(OnCritical);\n\n    // Add our callbacks to the Harbour using the settings\n    Harbour hb(settings);\n}\n</code></pre> <p>A common instance of working with callbacks would be to use a global Ship to log all paths requested on a server.</p> <p>Example</p> <p>This example will unset the default on_connection callback and instead use a global Ship in its place</p> <pre><code>auto ShowClientWithPath(const Request &amp;req) {\n    log::info(\"{}:{} \u2192 {}\", req.socket-&gt;address(), req.socket-&gt;port(), req.path);\n}\n\nauto main() -&gt; int {\n    // Disable the default on_connection callback and use a Ship instead\n    auto settings = server::Settings().with_on_connection(nullptr);\n    Harbour hb(settings);\n    hb.dock(ShowClientWithPath);\n    hb.sail();\n</code></pre> <p>Now whenever a client's Request is processed, we'll log the ip and port of the client and the requested path.</p> <p>The Connection callback is performed before a Request is parsed. So this is a common pattern when you want more fine-grained logging of a clients connection.</p> <p>Warning</p> <p>While these callbacks are coroutines, their execution is awaited inside the server.  It's important to note that if you do things such as file or network IO inside a callback that harbour will halt a clients processing until they finish.  It's preferable for such tasks to be deffered asynchronously for best performance.</p> <p>Note</p> <p>By default Harbour sets these callbacks to good defaults. Using your own callbacks should be reserved for specialty logging libraries or building metrics.</p>"},{"location":"features/middleware/","title":"Middleware","text":""},{"location":"home/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"home/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"home/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"home/code_of_conduct/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"home/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"home/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mail@nlohmann.me. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"home/code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at http://contributor-covenant.org/version/1/4</p>"},{"location":"home/design_goals/","title":"Design goals","text":""},{"location":"home/faq/","title":"Frequently Asked Questions (FAQ)","text":""},{"location":"home/license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 griefzz</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"home/releases/","title":"Releases","text":""},{"location":"integration/","title":"Header only","text":"<p><code>harbour.hpp</code> is the single required file in  to access all of harbours features</p> <pre><code>#include &lt;harbour/harbour.hpp&gt;\n\n// for convenience\nusing hb = harbour;\n</code></pre>"},{"location":"integration/cmake/","title":"CMake","text":""},{"location":"integration/cmake/#integration","title":"Integration","text":"<p>You can use the <code>harbour::harbour</code> interface target in CMake. This target populates the appropriate usage requirements for <code>INTERFACE_INCLUDE_DIRECTORIES</code> to point to the appropriate include directories and <code>INTERFACE_COMPILE_FEATURES</code> for the necessary C++20 flags.</p>"},{"location":"integration/cmake/#external","title":"External","text":"<p>To use this library from a CMake project, you can locate it directly with <code>find_package()</code> and use the namespaced imported target from the generated package configuration:</p> <p>Example</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.1)\nproject(ExampleProject LANGUAGES CXX)\n\nfind_package(harbour REQUIRED)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE harbour::harbour)\n</code></pre> <p>The package configuration file, <code>harbourConfig.cmake</code>, can be used either from an install tree or directly out of the build tree.</p>"},{"location":"integration/cmake/#embedded","title":"Embedded","text":"<p>To embed the library directly into an existing CMake project, place the entire source tree in a subdirectory and call <code>add_subdirectory()</code> in your <code>CMakeLists.txt</code> file.</p> <p>Example</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.1)\nproject(ExampleProject LANGUAGES CXX)\n\nadd_subdirectory(harbour)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE harbour::harbour)\n</code></pre> <p>Note</p> <p>Do not use <code>include(harbour/CMakeLists.txt)</code>, since that carries with it unintended consequences that will break the build. It is generally discouraged (although not necessarily well documented as such) to use <code>include(...)</code> for pulling in other CMake projects anyways.</p>"},{"location":"integration/cmake/#fetchcontent","title":"FetchContent","text":"<p>Since CMake v3.11, FetchContent can be used to automatically download a release as a dependency at configure type.</p> <p>Example</p> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.11)\nproject(ExampleProject LANGUAGES CXX)\n\ninclude(FetchContent)\n\nFetchContent_Declare(json\n    GIT_REPOSITORY https://github.com/griefzz/harbour\n    GIT_TAG master\n)\nFetchContent_MakeAvailable(harbour)\n\nadd_executable(example example.cpp)\ntarget_link_libraries(example PRIVATE harbour::harbour)\n</code></pre> <p>Note</p> <p>It is recommended to use the GIT_REPOSITORY approach described above.</p>"},{"location":"integration/dependencies/","title":"Dependencies","text":""},{"location":"start/","title":"Getting Started","text":"<p>This page will go over the basic concepts of harbour and how to create something meaningful with its api. After going through this you should have everything you need to start building!</p>"},{"location":"start/#running-a-server","title":"Running A Server","text":"<p>After linking harbour as described in Integration you can create a main.cpp file and begin configuring the server.</p> <p>Example</p> main.cpp<pre><code>#include &lt;harbour/harbour.hpp&gt;\n\nusing namespace harbour; // for convenience\n\nauto main() -&gt; int {\n    // Initialize harbour\n    Harbour harbour;\n\n    // Start the server\n    harbour.sail();\n}\n</code></pre> <p>Note</p> <p>By default harbour will open on port 8080. This can be changed with a server settings object for harbour.</p> <pre><code>// Create a server settings object using port 80 and construct harbour with it\nauto settings = server::Settings().with_port(80);\nHarbour harbour(settings);\n</code></pre>"},{"location":"start/#ships","title":"Ships","text":"<p>In order to do something meaningful with Harbour, we need to introduce the concept of Ships. Ships are your handlers that the server will use for operating on any given Request. Ships are extremely flexible functions that can return a Response to the client, or nothing at all!</p> <p>The most basic Ship can be done below.</p> <p>Example</p> <p>This ship will return a text response to the client when executed.</p> <pre><code>auto Hello() {\n    return \"Hello from Harbour!\";\n}\n</code></pre> <p>This ship will echo whatever a client sends to the server</p> <pre><code>auto Echo(const Request &amp;req) {\n    return req.data;\n}\n</code></pre> <p>This ship will optionally send a response if the client knows the password</p> <pre><code>auto Auth(const Request &amp;req) -&gt; std::optional&lt;Response&gt; {\n    if (req.body == \"let me in!\") \n        return \"Welcome!\";\n    return {};\n}\n</code></pre> <p>Ships can be any function that satisfies the ShipConcept. Harbour's Ships manage their flexibility through the use of <code>std::variant</code> and constexpr pattern matching.</p> <p>Example</p> <p>These are the 30 possible function signatures that satisfy the ShipConcept</p> <pre><code>auto Ship(const Request &amp;, Response &amp;) -&gt; void;\nauto Ship(const Request &amp;, Response &amp;) -&gt; Response;\nauto Ship(const Request &amp;, Response &amp;) -&gt; std::optional&lt;Response&gt;;\nauto Ship(const Request &amp;, Response &amp;) -&gt; awaitable&lt;Response&gt;;\nauto Ship(const Request &amp;, Response &amp;) -&gt; awaitable&lt;std::optional&lt;Response&gt;&gt;;\nauto Ship(const Request &amp;, Response &amp;) -&gt; awaitable&lt;void&gt;;\n\nauto Ship(Response &amp;, const Request &amp;) -&gt; void;\nauto Ship(Response &amp;, const Request &amp;) -&gt; Response;\nauto Ship(Response &amp;, const Request &amp;) -&gt; std::optional&lt;Response&gt;;\nauto Ship(Response &amp;, const Request &amp;) -&gt; awaitable&lt;Response&gt;;\nauto Ship(Response &amp;, const Request &amp;) -&gt; awaitable&lt;std::optional&lt;Response&gt;&gt;;\nauto Ship(Response &amp;, const Request &amp;) -&gt; awaitable&lt;void&gt;;\n\nauto Ship(const Request &amp;) -&gt; void;\nauto Ship(const Request &amp;) -&gt; Response;\nauto Ship(const Request &amp;) -&gt; std::optional&lt;Response&gt;;\nauto Ship(const Request &amp;) -&gt; awaitable&lt;Response&gt;;\nauto Ship(const Request &amp;) -&gt; awaitable&lt;std::optional&lt;Response&gt;&gt;;\nauto Ship(const Request &amp;) -&gt; awaitable&lt;void&gt;;\n\nauto Ship(Response &amp;) -&gt; void;\nauto Ship(Response &amp;) -&gt; Response;\nauto Ship(Response &amp;) -&gt; std::optional&lt;Response&gt;;\nauto Ship(Response &amp;) -&gt; awaitable&lt;Response&gt;;\nauto Ship(Response &amp;) -&gt; awaitable&lt;std::optional&lt;Response&gt;&gt;;\nauto Ship(Response &amp;) -&gt; awaitable&lt;void&gt;;\n\nauto Ship() -&gt; void;\nauto Ship() -&gt; Response;\nauto Ship() -&gt; std::optional&lt;Response&gt;;\nauto Ship() -&gt; awaitable&lt;Response&gt;;\nauto Ship() -&gt; awaitable&lt;std::optional&lt;Response&gt;&gt;;\nauto Ship() -&gt; awaitable&lt;void&gt;;\n</code></pre> <p>Ships are an extremely powerful and core concept in harbour. They maintain excellent flexibility while being as simple as possible to create. Harbour does its best to make the API as simple as possible so you can spend less time reading docs and more time building your project.</p>"},{"location":"start/#docking","title":"Docking","text":"<p>In order to use your Ships with harbour you must Dock them. Dock comes in 2 different flavours, <code>routed</code> and <code>global</code>.</p> <p>A <code>global</code> dock will execute Ships on any path in the server.</p> <p>A <code>routed</code> dock will execute Ships only on the specified route.</p> <p>Example</p> <p>This is an example of global Ship.</p> <pre><code>// Print the address and port of a new connection\nauto Log(const Request &amp;req) {\n    // logln will pretty print our prompt to std::clog with a new line\n    log::info(\"Connection: {}:{}\", req.socket.address(), req.socket.port());\n}\n\nauto main() -&gt; int {\n    Harbour harbour;\n    harbour.dock(Log); // Globally dock the ship\n    harbour.sail();\n}\n</code></pre> <p>This is an example of a routed Ship</p> <pre><code>// Return the number of visits to this Ship\nauto Counter() {\n    // Use an atomic variable since multiple connections \n    // could request this value at once\n    static std::atomic&lt;std::size_t&gt; n = 0;\n    n++;\n\n    // Convert the std::size_t to a std::string and return it\n    return std::to_string(n.load());\n}\n\nauto main() -&gt; int {\n    Harbour harbour;\n    harbour.dock(\"/counter\", Counter); // dock the ship to \"/counter\"\n    harbour.sail();\n}\n</code></pre> <p>Note</p> <p><code>dock()</code> also accepts any number of ships as parameters and returns a reference to Harbour. It's encouraged to use dock this way.</p> <pre><code>harbour.dock(foo_a, foo_b)\n       .dock(bar_a, bar_b)\n       .dock(baz_a, baz_b, baz_c);\n</code></pre> <p>Chaining is not required and multiple dock calls can be done at any time!</p> <p>Warning</p> <p>It's important to note that Ships are executed in a FIFO order and will exit at the first instance of a Ship returning a valid Response.</p> <pre><code>auto Foo() -&gt; void { ... };\n\n// An empty optional is *not* a valid Response\nauto Bar() -&gt; std::optional&lt;Response&gt; { return {}; }\n\n// This *is* considered a valid Response\nauto Baz() -&gt; Response { return \"Baz\"; } \n\nauto Boz() -&gt; void { ... }\n\nauto main() -&gt; int {\n    ...\n    // Baz will execute since an empty optional is not a *valid* Response.\n    // Boz will never be reached since Baz *does* return a Response \n    hb.dock(Foo, Bar, Baz, Boz);\n    ...\n}\n</code></pre> <p>If you want to modify a Response between Ships you should use the Response&amp; parameter in your Ships.</p> <p>If no Ship returns a valid Response. The Response&amp; parameter will ultimately be returned instead.</p>"},{"location":"start/#start-building","title":"Start Building","text":"<p>That should cover most of the important concepts in harbour and have you prepared to start building!</p>"},{"location":"start/#features","title":"Features","text":"<p>Harbour is batteries included!</p> <ul> <li>First class JSON support through the bespoke nlohmann::json library.</li> <li>Secure cookies using AES256 and HMAC authentication.  </li> <li>Template rendering provided by fmtlib. </li> </ul> <p>Head over to Features to get an overview of what Harbour has to offer!</p>"},{"location":"start/#api","title":"API","text":"<p>Generate the full documentation for Harbour's API using doxygen.</p>"}]}